<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Omni Semantic Layer — Tree</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f1117;
      color: #e2e8f0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 12px 20px;
      display: flex;
      align-items: center;
      gap: 14px;
      border-bottom: 1px solid #1e2533;
      flex-shrink: 0;
    }
    header h1 { font-size: 15px; font-weight: 600; color: #f1f5f9; }

    .nav-link {
      font-size: 12px; color: #7c8cf8; text-decoration: none;
      padding: 3px 10px; border: 1px solid #334155; border-radius: 4px;
      transition: background 0.15s;
    }
    .nav-link:hover { background: #1e2533; color: #a5b4fc; }

    .header-btn {
      font-size: 12px; color: #94a3b8; cursor: pointer;
      padding: 3px 10px; border: 1px solid #334155; border-radius: 4px;
      background: none; transition: background 0.15s;
    }
    .header-btn:hover { background: #1e2533; color: #cbd5e1; }

    #stats {
      margin-left: auto; font-size: 12px; color: #475569;
      display: flex; gap: 14px;
    }
    #stats b { color: #94a3b8; }

    /* ── Chart: scrollable container ── */
    #chart {
      flex: 1;
      overflow: auto;
      position: relative;
      padding: 20px 0 40px 0;
    }

    /* SVG grows to fit content */
    #tree-svg {
      display: block;
      overflow: visible;
    }

    /* ── Node groups ── */
    .node { cursor: pointer; }
    .node.node--leaf { cursor: default; }

    .node circle {
      stroke-width: 2px;
      transition: r 0.12s, fill 0.12s;
    }
    .node:not(.node--leaf):hover circle {
      r: 5.5;
    }

    .node text {
      font-size: 12px;
      dominant-baseline: middle;
      pointer-events: none;
      user-select: none;
    }

    /* ── Links ── */
    .link {
      fill: none;
      stroke-opacity: 0.5;
      stroke-width: 1.5px;
    }

    /* ── Legend ── */
    #legend {
      padding: 8px 20px;
      display: flex; gap: 18px; align-items: center; flex-wrap: wrap;
      border-top: 1px solid #1e2533;
      flex-shrink: 0;
      font-size: 11px; color: #64748b;
    }
    .legend-item { display: flex; align-items: center; gap: 5px; }
    .legend-dot  { width: 9px; height: 9px; border-radius: 50%; flex-shrink: 0; }
    #legend .hint { margin-left: auto; font-size: 11px; color: #334155; }
    #legend .sep  { color: #334155; }

    /* ── Tooltip ── */
    #tooltip {
      position: fixed; pointer-events: none;
      background: #1e2533; border: 1px solid #334155; border-radius: 6px;
      padding: 9px 12px; font-size: 12px; line-height: 1.6;
      max-width: 280px; box-shadow: 0 4px 16px rgba(0,0,0,0.5);
      opacity: 0; transition: opacity 0.1s; z-index: 100;
    }
    #tooltip.visible { opacity: 1; }
    #tooltip .tt-title { font-weight: 700; font-size: 13px; color: #f1f5f9; margin-bottom: 3px; }
    #tooltip .tt-row   { color: #94a3b8; }
    #tooltip .tt-row b { color: #cbd5e1; }
    #tooltip code      { font-size: 11px; color: #7c8cf8; }
  </style>
</head>
<body>

<header>
  <h1>Omni Semantic Layer — Tree</h1>
  <a href="treemap.html" class="nav-link">⬛ Treemap view</a>
  <button class="header-btn" id="btn-reset">↺ Reset view</button>
  <button class="header-btn" id="btn-expand-topics">⊕ Expand all topics</button>
  <div id="stats"></div>
</header>

<div id="chart">
  <svg id="tree-svg"><g id="tree-g"></g></svg>
</div>

<div id="legend"></div>
<div id="tooltip"></div>

<script>
// ── Palette ────────────────────────────────────────────────────────────────
const DIM_COLOR       = "#1d4ed8";
const MEAS_COLOR      = "#047857";
const TOPIC_COLOR     = "#7c3aed";
const JOIN_COLOR      = "#d97706";
const BASE_VIEW_COLOR = "#0e7490";
const JOIN_REF_COLOR  = "#5b21b6";
const SCHEMA_COLORS   = d3.schemeTableau10;

// ── Layout constants ───────────────────────────────────────────────────────
const DX         = 20;    // vertical gap between sibling nodes (px)
const DY         = 230;   // horizontal gap between depth levels (px)
const MARGIN_L   = 60;
const MARGIN_T   = DX * 2;
const DURATION   = 300;

d3.json("treemap.json").then(rawData => {

  // ── Annotate _category & _schema ─────────────────────────────────────
  function annotate(node, depth, cat, schema) {
    if (depth === 1) { node._category = node.name; cat = node.name; }
    else             { node._category = cat; }
    if (cat === "views") {
      if (depth === 2)   { node._schema = node.name; schema = node.name; }
      else if (depth > 2){ node._schema = schema; }
    }
    (node.children || []).forEach(c => annotate(c, depth + 1, cat, schema));
  }
  annotate(rawData, 0, null, null);

  // ── Colour helpers ─────────────────────────────────────────────────────
  const viewsNode   = rawData.children.find(c => c.name === "views");
  const schemas     = viewsNode ? viewsNode.children.map(d => d.name) : [];
  const schemaColor = d3.scaleOrdinal(schemas, SCHEMA_COLORS);

  function nodeColor(d) {
    const dt = d.data || d;   // works with both d3 node and raw data
    if (!dt) return "#475569";
    if (dt.ref_type === "base_view")   return BASE_VIEW_COLOR;
    if (dt.ref_type === "join")        return JOIN_REF_COLOR;
    if (dt.field_type === "dimension") return DIM_COLOR;
    if (dt.field_type === "measure")   return MEAS_COLOR;
    if (dt.name === "dimensions")      return DIM_COLOR;
    if (dt.name === "measures")        return MEAS_COLOR;
    const cat = dt._category;
    if (cat === "topics") {
      const depth = d.depth !== undefined ? d.depth : 0;
      return d3.color(TOPIC_COLOR).darker([0,0,0.3,0.7,1.1][Math.min(depth,4)]).formatHex();
    }
    if (cat === "joins") {
      const depth = d.depth !== undefined ? d.depth : 0;
      return d3.color(JOIN_COLOR).darker([0,0,0.3,0.6][Math.min(depth,3)]).formatHex();
    }
    const base = d3.color(schemaColor(dt._schema || dt.name));
    if (!base) return "#334155";
    const depth = d.depth !== undefined ? d.depth : 0;
    return base.darker([0,0,0.2,0.5,0.9,1.3][Math.min(depth,5)]).formatHex();
  }

  // ── Enrich topics/joins refs with view field data ──────────────────────
  // Build lookup: bare view name → view data node (with children)
  const viewByName = new Map();
  if (viewsNode) {
    viewsNode.children.forEach(schema => {
      (schema.children || []).forEach(view => {
        viewByName.set(view.name, view);
      });
    });
  }

  function findViewData(name) {
    if (viewByName.has(name)) return viewByName.get(name);
    // Strip prefix: "ecomm__users" → "users"
    const idx = name.indexOf("__");
    if (idx !== -1) {
      const bare = name.slice(idx + 2);
      if (viewByName.has(bare)) return viewByName.get(bare);
    }
    return null;
  }

  function deepClone(obj) { return JSON.parse(JSON.stringify(obj)); }

  function enrichRefs(sectionNode) {
    (sectionNode.children || []).forEach(parent => {
      (parent.children || []).forEach(ref => {
        if (!ref.children) {
          const vd = findViewData(ref.name);
          if (vd && vd.children && vd.children.length > 0) {
            ref.children = deepClone(vd.children);
            // Propagate _category and _schema onto enriched children
            ref.children.forEach(g => {
              g._category = "views";
              g._schema   = vd._schema || vd.name;
              (g.children || []).forEach(f => {
                f._category = "views";
                f._schema   = vd._schema || vd.name;
              });
            });
          }
        }
      });
    });
  }

  const topicsNode = rawData.children.find(c => c.name === "topics");
  const joinsNode  = rawData.children.find(c => c.name === "joins");
  if (topicsNode) enrichRefs(topicsNode);
  if (joinsNode)  enrichRefs(joinsNode);

  // Re-annotate after enrichment
  annotate(rawData, 0, null, null);

  // ── Build d3 hierarchy ─────────────────────────────────────────────────
  const root = d3.hierarchy(rawData);
  let uid = 0;
  root.descendants().forEach(d => {
    d.id = ++uid;
    d.x0 = 0; d.y0 = 0;
  });

  // Collapse all nodes at depth >= 2
  root.descendants().forEach(d => {
    if (d.depth >= 2 && d.children) {
      d._children = d.children;
      d.children  = null;
    }
  });

  // ── Layout ──────────────────────────────────────────────────────────────
  const treeLayout = d3.tree().nodeSize([DX, DY]);
  const diagonal   = d3.linkHorizontal().x(d => d.y).y(d => d.x);

  // ── SVG setup ───────────────────────────────────────────────────────────
  const svg = d3.select("#tree-svg");
  const g   = d3.select("#tree-g");

  // ── Node fill logic (Observable-inspired) ─────────────────────────────
  // collapsed (has _children) → solid colored fill
  // expanded  (has children)  → dark bg + colored ring
  // leaf                      → muted gray
  function circleFill(d) {
    if (d._children) return nodeColor(d);           // collapsed → solid
    if (d.children)  return "#1a2233";              // expanded  → dark ring
    return "#334155";                               // true leaf
  }

  function circleStroke(d) {
    if (d.depth === 0) return "#64748b";
    return d3.color(nodeColor(d)).brighter(0.5).formatHex();
  }

  function circleR(d) {
    if (d.depth === 0) return 6;
    if (d.depth === 1) return 5;
    if (d._children || d.children) return 4;
    return 3;
  }

  function labelText(d) {
    const raw  = d.data.label || d.data.name || "";
    const name = raw.length > 38 ? raw.slice(0, 37) + "…" : raw;
    if (d._children) {
      const n = d._children.length;
      return `${name}  +${n}`;
    }
    return name;
  }

  function labelFill(d) {
    if (d.depth === 0 || d.depth === 1) return "#f1f5f9";
    if (d._children) return "#e2e8f0";
    return "#94a3b8";
  }

  function labelWeight(d) { return d.depth <= 1 ? "600" : "400"; }
  function labelSize(d)   { return d.depth <= 1 ? "13px" : "12px"; }

  // ── Update function ─────────────────────────────────────────────────────
  function update(source) {
    treeLayout(root);

    const nodes = root.descendants();
    const links = root.links();

    // Compute bounding box of visible nodes → resize SVG
    let xMin = Infinity, xMax = -Infinity, yMax = -Infinity;
    nodes.forEach(d => {
      if (d.x < xMin) xMin = d.x;
      if (d.x > xMax) xMax = d.x;
      if (d.y > yMax) yMax = d.y;
    });
    const svgH = xMax - xMin + MARGIN_T * 2;
    const svgW = yMax + DY + MARGIN_L;

    svg.transition().duration(DURATION)
      .attr("width",   svgW)
      .attr("height",  svgH)
      .attr("viewBox", [-MARGIN_L, xMin - MARGIN_T, svgW, svgH]);

    // ── Links ──────────────────────────────────────────────────────────
    const link = g.selectAll("path.link")
      .data(links, d => d.target.id);

    const linkEnter = link.enter().insert("path", "g.node")
      .attr("class", "link")
      .attr("d", () => {
        const o = { x: source.x0, y: source.y0 };
        return diagonal({ source: o, target: o });
      });

    linkEnter.merge(link)
      .transition().duration(DURATION)
      .attr("d", diagonal)
      .attr("stroke", d => {
        const c = d3.color(nodeColor(d.target));
        return c ? c.formatHex() : "#334155";
      });

    link.exit().transition().duration(DURATION)
      .attr("d", () => {
        const o = { x: source.x, y: source.y };
        return diagonal({ source: o, target: o });
      })
      .remove();

    // ── Nodes ──────────────────────────────────────────────────────────
    const node = g.selectAll("g.node")
      .data(nodes, d => d.id);

    const nodeEnter = node.enter().append("g")
      .attr("class", "node")
      .attr("transform", `translate(${source.y0},${source.x0})`)
      .attr("fill-opacity", 0)
      .attr("stroke-opacity", 0);

    nodeEnter.append("circle");
    // Label background (white halo for readability, Observable style)
    nodeEnter.append("text").attr("class", "label-bg");
    nodeEnter.append("text").attr("class", "label-fg");

    const nodeMerge = nodeEnter.merge(node);

    // Leaf class
    nodeMerge.classed("node--leaf", d => !d.children && !d._children);

    // Circle
    nodeMerge.select("circle")
      .attr("r",      circleR)
      .attr("fill",   circleFill)
      .attr("stroke", circleStroke);

    // Label (background – white stroke halo)
    nodeMerge.select("text.label-bg")
      .attr("x",           d => circleR(d) + 6)
      .attr("fill",        "none")
      .attr("stroke",      "#0f1117")
      .attr("stroke-width", 3)
      .attr("stroke-linejoin", "round")
      .attr("font-weight", labelWeight)
      .attr("font-size",   labelSize)
      .text(labelText);

    // Label (foreground)
    nodeMerge.select("text.label-fg")
      .attr("x",           d => circleR(d) + 6)
      .attr("fill",        labelFill)
      .attr("font-weight", labelWeight)
      .attr("font-size",   labelSize)
      .text(labelText);

    // Events
    nodeMerge
      .on("click", (event, d) => {
        if (!d.children && !d._children) return;
        if (d.children) { d._children = d.children; d.children = null; }
        else             { d.children = d._children; d._children = null; }
        update(d);
      })
      .on("mousemove", showTooltip)
      .on("mouseleave", hideTooltip);

    // Transition in
    nodeMerge.transition().duration(DURATION)
      .attr("transform", d => `translate(${d.y},${d.x})`)
      .attr("fill-opacity", 1)
      .attr("stroke-opacity", 1);

    // Exit
    node.exit().transition().duration(DURATION)
      .attr("transform", `translate(${source.y},${source.x})`)
      .attr("fill-opacity", 0)
      .attr("stroke-opacity", 0)
      .remove();

    // Save positions
    nodes.forEach(d => { d.x0 = d.x; d.y0 = d.y; });

    updateStats(nodes);
  }

  // ── Tooltip ─────────────────────────────────────────────────────────────
  const tooltipEl = document.getElementById("tooltip");

  function showTooltip(event, d) {
    const dt   = d.data;
    const rows = [];
    if (d.depth > 1 && dt._category)
      rows.push(`<div class="tt-row"><b>Section:</b> ${dt._category}</div>`);
    if (dt.ref_type === "base_view")
      rows.push(`<div class="tt-row"><b>Role:</b> base view ref</div>`);
    else if (dt.ref_type === "join")
      rows.push(`<div class="tt-row"><b>Role:</b> join ref</div>`);
    if (dt.base_view && !dt.ref_type)
      rows.push(`<div class="tt-row"><b>Base view:</b> ${dt.base_view}</div>`);
    if (dt.table_name)
      rows.push(`<div class="tt-row"><b>Table:</b> ${dt.table_name}</div>`);
    if (dt._schema)
      rows.push(`<div class="tt-row"><b>Schema:</b> ${dt._schema}</div>`);
    if (dt.field_type)
      rows.push(`<div class="tt-row"><b>Type:</b> ${dt.field_type}</div>`);
    if (dt.aggregate_type)
      rows.push(`<div class="tt-row"><b>Aggregate:</b> ${dt.aggregate_type}</div>`);
    if (dt.sql)
      rows.push(`<div class="tt-row"><b>SQL:</b> <code>${dt.sql}</code></div>`);
    const hidden = d._children ? d._children.length : 0;
    if (hidden)
      rows.push(`<div class="tt-row"><b>Hidden children:</b> ${hidden}</div>`);

    tooltipEl.innerHTML = `<div class="tt-title">${dt.label || dt.name}</div>${rows.join("")}`;
    tooltipEl.classList.add("visible");
    const margin = 14;
    let tx = event.clientX + margin;
    let ty = event.clientY + margin;
    tooltipEl.style.left = "0px"; tooltipEl.style.top = "0px";
    // defer measurement
    requestAnimationFrame(() => {
      const tw = tooltipEl.offsetWidth, th = tooltipEl.offsetHeight;
      if (tx + tw > window.innerWidth)  tx = event.clientX - tw - margin;
      if (ty + th > window.innerHeight) ty = event.clientY - th - margin;
      tooltipEl.style.left = tx + "px";
      tooltipEl.style.top  = ty + "px";
    });
  }

  function hideTooltip() { tooltipEl.classList.remove("visible"); }

  // ── Stats bar ───────────────────────────────────────────────────────────
  function updateStats(nodes) {
    const visible  = nodes.length;
    const expanded = nodes.filter(d => d.children).length;
    const collapsed = nodes.filter(d => d._children).length;
    document.getElementById("stats").innerHTML =
      `<span><b>${visible}</b> visible</span>` +
      `<span><b>${expanded}</b> expanded</span>` +
      `<span><b>${collapsed}</b> collapsed</span>`;
  }

  // ── Legend ──────────────────────────────────────────────────────────────
  function buildLegend() {
    const el = document.getElementById("legend");
    const schemaItems = schemas.map(s =>
      `<div class="legend-item">
         <div class="legend-dot" style="background:${schemaColor(s)}"></div>
         <span>${s}</span>
       </div>`
    ).join("");

    el.innerHTML =
      `<div class="legend-item"><div class="legend-dot" style="background:${TOPIC_COLOR}"></div><span>topics</span></div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${JOIN_COLOR}"></div><span>joins</span></div>` +
      `<span class="sep">|</span>` +
      schemaItems +
      `<span class="sep">|</span>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${BASE_VIEW_COLOR}"></div><span>base view</span></div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${JOIN_REF_COLOR}"></div><span>join ref</span></div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${DIM_COLOR}"></div><span>dimensions</span></div>` +
      `<div class="legend-item"><div class="legend-dot" style="background:${MEAS_COLOR}"></div><span>measures</span></div>` +
      `<span class="hint">Click node to expand / collapse · Solid = collapsed, ring = expanded</span>`;
  }

  buildLegend();

  // ── Buttons ─────────────────────────────────────────────────────────────
  document.getElementById("btn-reset").addEventListener("click", () => {
    root.descendants().forEach(d => {
      if (d.depth < 2) {
        // Ensure root and section nodes (depth 0, 1) are expanded
        if (!d.children && d._children) { d.children = d._children; d._children = null; }
      } else {
        // Collapse everything at depth >= 2
        if (d.children) { d._children = d.children; d.children = null; }
      }
    });
    update(root);
    setTimeout(() => {
      document.getElementById("chart").scrollTo({ top: 0, left: 0, behavior: "smooth" });
    }, DURATION);
  });

  document.getElementById("btn-expand-topics").addEventListener("click", () => {
    // Expand topics section one level (depth 2 → depth 3 refs become visible)
    if (topicsNode) {
      const topicsH = root.descendants().find(d => d.data === topicsNode);
      if (topicsH) {
        // Ensure topics is expanded
        if (!topicsH.children && topicsH._children) {
          topicsH.children = topicsH._children; topicsH._children = null;
        }
        // Expand each individual topic (depth 2)
        topicsH.children.forEach(topicH => {
          if (!topicH.children && topicH._children) {
            topicH.children = topicH._children; topicH._children = null;
          }
        });
      }
    }
    update(root);
  });

  // ── Initial render ──────────────────────────────────────────────────────
  root.x0 = 0; root.y0 = 0;
  update(root);

}).catch(err => {
  document.getElementById("chart").innerHTML =
    `<p style="padding:20px;color:#f87171">Failed to load treemap.json: ${err.message}</p>`;
});
</script>
</body>
</html>
