<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Omni Schema Treemap</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0f1117;
      color: #e2e8f0;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }

    header {
      padding: 14px 20px;
      display: flex;
      align-items: center;
      gap: 16px;
      border-bottom: 1px solid #1e2533;
      flex-shrink: 0;
    }
    header h1 { font-size: 16px; font-weight: 600; color: #f1f5f9; }

    #breadcrumb {
      font-size: 13px;
      color: #64748b;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    #breadcrumb span { cursor: pointer; color: #7c8cf8; transition: color 0.15s; }
    #breadcrumb span:hover { color: #a5b4fc; }
    #breadcrumb .sep { color: #334155; cursor: default; }
    #breadcrumb .current { color: #94a3b8; cursor: default; }

    #stats {
      margin-left: auto;
      font-size: 12px;
      color: #475569;
      display: flex;
      gap: 16px;
    }
    #stats b { color: #94a3b8; }

    #chart {
      flex: 1;
      overflow: hidden;
      position: relative;
    }
    svg { width: 100%; height: 100%; display: block; }

    /* ── cells ── */
    .cell { cursor: pointer; }
    .cell rect {
      stroke: #0f1117;
      stroke-width: 1.5px;
      transition: filter 0.12s;
    }
    .cell:hover rect { filter: brightness(1.3); }
    .cell text {
      pointer-events: none;
      dominant-baseline: hanging;
      fill: rgba(255,255,255,0.92);
    }
    .cell text.label-name { font-size: 12px; font-weight: 600; }
    .cell text.label-sub  { font-size: 10px; fill: rgba(255,255,255,0.52); }

    /* Group cells (dimensions / measures) get a subtle inner border */
    .cell-group rect {
      stroke: rgba(255,255,255,0.18);
      stroke-width: 1px;
    }

    /* Individual field cells */
    .cell-field rect { stroke-width: 0.5px; }
    .cell-field text.label-name { font-size: 11px; font-weight: 500; }

    /* Ref cells (base_view / join refs inside topics) */
    .cell-ref rect { stroke-width: 0.5px; }
    .cell-ref text.label-name { font-size: 11px; font-weight: 500; }

    /* Tooltip */
    #tooltip {
      position: absolute;
      pointer-events: none;
      background: #1e2533;
      border: 1px solid #334155;
      border-radius: 6px;
      padding: 10px 12px;
      font-size: 12px;
      line-height: 1.6;
      max-width: 260px;
      box-shadow: 0 4px 16px rgba(0,0,0,0.5);
      opacity: 0;
      transition: opacity 0.1s;
    }
    #tooltip.visible { opacity: 1; }
    #tooltip .tt-title { font-weight: 700; font-size: 13px; color: #f1f5f9; margin-bottom: 4px; }
    #tooltip .tt-row   { color: #94a3b8; }
    #tooltip .tt-row b { color: #cbd5e1; }

    #legend {
      padding: 10px 20px;
      display: flex;
      gap: 20px;
      align-items: center;
      border-top: 1px solid #1e2533;
      flex-shrink: 0;
      font-size: 12px;
      color: #64748b;
      flex-wrap: wrap;
    }
    .legend-item { display: flex; align-items: center; gap: 6px; }
    .legend-swatch { width: 12px; height: 12px; border-radius: 2px; flex-shrink: 0; }
    #legend .hint { margin-left: auto; font-size: 11px; }
    #legend .legend-sep { color: #1e2533; }
  </style>
</head>
<body>

<header>
  <h1>Omni Schema Treemap</h1>
  <div id="breadcrumb"><span class="current">omni</span></div>
  <div id="stats"></div>
</header>

<div id="chart">
  <svg id="treemap-svg"></svg>
  <div id="tooltip"></div>
</div>

<div id="legend"></div>

<script>
const SCHEMA_COLORS  = d3.schemeTableau10;
const DIM_COLOR       = "#1d4ed8";  // blue-700
const MEAS_COLOR      = "#047857";  // emerald-700
const TOPIC_COLOR     = "#7c3aed";  // violet-600
const JOIN_COLOR      = "#d97706";  // amber-600
const BASE_VIEW_COLOR = "#0e7490";  // cyan-700
const JOIN_REF_COLOR  = "#5b21b6";  // violet-800

d3.json("treemap.json").then(data => {

  // ── 1. Pre-compute cumulative counts on every node ────────────────────────
  function precomputeCount(node) {
    if (!node.children || !node.children.length) {
      return (node._count = node.value ?? 1);
    }
    return (node._count = node.children.reduce((s, c) => s + precomputeCount(c), 0));
  }
  precomputeCount(data);

  // ── 2. Annotate category + schema ancestry ────────────────────────────────
  // depth 1 nodes are "topics" | "joins" | "views" — their name becomes the category.
  // Under "views", depth-2 nodes are schemas.
  function annotate(node, depth, category, schema) {
    if (depth === 1) {
      node._category = node.name;
      category = node.name;
    } else {
      node._category = category;
    }
    if (category === "views") {
      if (depth === 2) { node._schema = node.name; schema = node.name; }
      else if (depth > 2) { node._schema = schema; }
    }
    if (node.children) {
      node.children.forEach(c => annotate(c, depth + 1, category, schema));
    }
  }
  annotate(data, 0, null, null);

  // ── 3. Summary view ───────────────────────────────────────────────────────
  // Collapse field-groups (nodes whose direct children are individual fields)
  // into leaf nodes. Ref nodes (ref_type) are already leaves — pass through.
  function summaryView(node, isRoot = false) {
    if (!node.children) return { ...node, _orig: node };

    // Collapse field-groups (dimensions / measures) into leaf nodes
    const childrenAreFields = node.children.some(c => c.field_type != null);
    if (childrenAreFields) {
      return {
        name:     node.name,
        value:    node._count,
        _orig:    node,
        _schema:  node._schema,
        _isGroup: true,
      };
    }

    // Collapse view nodes into single leaves — unless this view IS the root being rendered
    if (node.table_name && !isRoot) {
      return {
        name:       node.name,
        value:      1,
        _orig:      node,
        _schema:    node._schema,
        _isView:    true,
        table_name: node.table_name,
      };
    }

    return {
      ...node,
      _orig: node,
      children: node.children.map(c => summaryView(c)),
    };
  }

  // ── Schema color scale (scoped to the "views" section) ────────────────────
  const viewsNode  = data.children.find(c => c.name === "views");
  const schemas    = viewsNode ? viewsNode.children.map(d => d.name) : [];

  // ── View lookup: find any view node by name ───────────────────────────────
  const viewByName = {};
  if (viewsNode) {
    viewsNode.children.forEach(schema =>
      schema.children.forEach(view => { viewByName[view.name] = view; })
    );
  }

  // Topic join refs use a model-prefixed naming convention (e.g. "ecomm__users")
  // while view files use the bare name ("users"). Try stripping the prefix on miss.
  function findView(name) {
    if (viewByName[name]) return viewByName[name];
    const idx = name.indexOf("__");
    if (idx !== -1) {
      const suffix = name.slice(idx + 2);
      if (viewByName[suffix]) return viewByName[suffix];
    }
    return null;
  }
  const schemaColor = d3.scaleOrdinal(schemas, SCHEMA_COLORS);

  const svg     = d3.select("#treemap-svg");
  const chartEl = document.getElementById("chart");
  const tooltip = document.getElementById("tooltip");

  let currentOrigData = data;
  const breadcrumbPath = [data];

  function getSize() {
    const r = chartEl.getBoundingClientRect();
    return { w: r.width, h: r.height };
  }

  // ── Cell colour ───────────────────────────────────────────────────────────
  function cellColor(d, isDetail) {
    if (isDetail) {
      return currentOrigData.name === "measures" ? MEAS_COLOR : DIM_COLOR;
    }
    if (d.data._isGroup) {
      return d.data.name === "measures" ? MEAS_COLOR : DIM_COLOR;
    }
    if (d.data.ref_type === "base_view") return BASE_VIEW_COLOR;
    if (d.data.ref_type === "join")      return JOIN_REF_COLOR;

    const cat = d.data._category;

    if (cat === "topics") {
      const base = d3.color(TOPIC_COLOR);
      const relDepth = Math.max(0, d.depth - 1);
      const darkness = [0, 0.5, 1.0][Math.min(relDepth, 2)];
      return base.darker(darkness).formatHex();
    }
    if (cat === "joins") {
      const base = d3.color(JOIN_COLOR);
      const relDepth = Math.max(0, d.depth - 1);
      const darkness = [0, 0.5, 1.0][Math.min(relDepth, 2)];
      return base.darker(darkness).formatHex();
    }

    // views — colour by schema, darken by depth within views section
    const key  = d.data._schema || d.data.name;
    const base = d3.color(schemaColor(key));
    if (!base) return "#334155";
    // depth 2=schema, 3=view, 4=group → relDepth 0,1,2
    const relDepth = Math.max(0, d.depth - 2);
    const darkness = [0, 0.35, 0.95, 1.5][Math.min(relDepth, 3)];
    return base.darker(darkness).formatHex();
  }

  // ── Main render ───────────────────────────────────────────────────────────
  function render(rootOrigData) {
    currentOrigData = rootOrigData;

    const isDetail = !!(
      rootOrigData.children &&
      rootOrigData.children.some(c => c.field_type != null)
    );

    const displayData = isDetail ? rootOrigData : summaryView(rootOrigData, true);

    const { w, h } = getSize();
    svg.attr("viewBox", `0 0 ${w} ${h}`);

    const root = d3.hierarchy(displayData)
      .sum(d => d.value ?? 0)
      .sort((a, b) => b.value - a.value);

    updateBreadcrumb(rootOrigData);
    updateStats(root, isDetail);

    d3.treemap()
      .size([w, h])
      .paddingOuter(4)
      .paddingTop(d => {
        if (isDetail) return d.depth === 0 ? 28 : 0;
        return d.depth === 0 ? 4 : (d.depth < 4 ? 22 : 0);
      })
      .paddingInner(isDetail ? 1 : 2)
      .round(true)
      (root);

    svg.selectAll("*").remove();

    if (isDetail) {
      svg.append("text")
        .attr("x", 8).attr("y", 18)
        .attr("dominant-baseline", "middle")
        .attr("font-family", "-apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif")
        .attr("font-size", 13).attr("font-weight", 700)
        .attr("fill", "#f1f5f9")
        .text(`${rootOrigData.name}  ·  ${rootOrigData._count} fields`);
    }

    const nodes = root.descendants().filter(d => d.depth > 0);

    const cell = svg.selectAll("g.cell")
      .data(nodes)
      .join("g")
      .attr("class", d => {
        let c = "cell";
        if (!d.children)        c += " cell-leaf";
        if (d.data._isGroup)    c += " cell-group";
        if (isDetail)           c += " cell-field";
        if (d.data.ref_type)    c += " cell-ref";
        return c;
      })
      .attr("transform", d => `translate(${d.x0},${d.y0})`);

    const cw = d => Math.max(0, d.x1 - d.x0);
    const ch = d => Math.max(0, d.y1 - d.y0);

    cell.append("rect")
      .attr("width",  cw)
      .attr("height", ch)
      .attr("fill",   d => cellColor(d, isDetail))
      .attr("rx", 3);

    // Primary name label
    cell.append("text")
      .attr("class", "label-name")
      .attr("x", 5).attr("y", 5)
      .text(d => {
        const w = cw(d);
        if (w < 28) return "";
        const name = d.data.label || d.data.name;
        const max  = Math.floor(w / 7);
        return name.length > max ? name.slice(0, max - 1) + "…" : name;
      });

    // Sub-label for field-group cells
    cell.filter(d => d.data._isGroup)
      .append("text")
      .attr("class", "label-sub")
      .attr("x", 5).attr("y", 20)
      .text(d => {
        if (cw(d) < 90 || ch(d) < 32) return "";
        return `${d.data.value} fields — click to expand ↓`;
      });

    // Sub-label for ref cells
    cell.filter(d => d.data.ref_type)
      .append("text")
      .attr("class", "label-sub")
      .attr("x", 5).attr("y", 20)
      .text(d => {
        if (cw(d) < 60 || ch(d) < 32) return "";
        const role = d.data.ref_type === "base_view" ? "base view" : "join";
        return findView(d.data.name) ? `${role} — click to explore ↓` : role;
      });

    // Sub-label for collapsed view cells
    cell.filter(d => d.data._isView)
      .append("text")
      .attr("class", "label-sub")
      .attr("x", 5).attr("y", 20)
      .text(d => {
        if (cw(d) < 70 || ch(d) < 32) return "";
        return `${d.data._orig._count} fields — click ↓`;
      });

    // Sub-label for parent nodes in summary mode: total item count
    if (!isDetail) {
      cell.filter(d => d.children && !d.data._isGroup && !d.data.ref_type)
        .append("text")
        .attr("class", "label-sub")
        .attr("x", 5).attr("y", 20)
        .text(d => {
          if (cw(d) < 60) return "";
          return `${d.value} items`;
        });
    }

    // Sub-label for individual fields in detail mode
    if (isDetail) {
      cell.append("text")
        .attr("class", "label-sub")
        .attr("x", 5).attr("y", 20)
        .text(d => {
          if (cw(d) < 48 || ch(d) < 32) return "";
          return d.data.aggregate_type || d.data.format || "";
        });
    }

    // ── Tooltip ───────────────────────────────────────────────────────────────
    cell.on("mousemove", (event, d) => {
      const orig = d.data._orig || d.data;
      const rows = [];
      if (orig.ref_type === "base_view") rows.push(`<div class="tt-row"><b>Role:</b> base view</div>`);
      if (orig.ref_type === "join")      rows.push(`<div class="tt-row"><b>Role:</b> joined view</div>`);
      if (orig.base_view && !orig.ref_type)
                                         rows.push(`<div class="tt-row"><b>Base view:</b> ${orig.base_view}</div>`);
      if (orig.table_name)               rows.push(`<div class="tt-row"><b>Table:</b> ${orig.table_name}</div>`);
      if (d.data._isGroup)               rows.push(`<div class="tt-row"><b>Fields:</b> ${d.data.value}</div>`);
      if (orig.field_type)               rows.push(`<div class="tt-row"><b>Type:</b> ${orig.field_type}</div>`);
      if (orig.aggregate_type)           rows.push(`<div class="tt-row"><b>Aggregate:</b> ${orig.aggregate_type}</div>`);
      if (orig.format)                   rows.push(`<div class="tt-row"><b>Format:</b> ${orig.format}</div>`);
      if (orig.sql)                      rows.push(`<div class="tt-row"><b>SQL:</b> <code>${orig.sql}</code></div>`);
      if (orig._schema)                  rows.push(`<div class="tt-row"><b>Schema:</b> ${orig._schema}</div>`);

      tooltip.innerHTML =
        `<div class="tt-title">${d.data.label || d.data.name}</div>${rows.join("")}`;
      tooltip.classList.add("visible");

      const rect = chartEl.getBoundingClientRect();
      let tx = event.clientX - rect.left + 14;
      let ty = event.clientY - rect.top  + 14;
      if (tx + 280 > rect.width)  tx = event.clientX - rect.left - 280;
      if (ty + tooltip.offsetHeight > rect.height)
        ty = event.clientY - rect.top - tooltip.offsetHeight - 4;
      tooltip.style.left = tx + "px";
      tooltip.style.top  = ty + "px";
    })
    .on("mouseleave", () => tooltip.classList.remove("visible"));

    // ── Click: drill down ─────────────────────────────────────────────────────
    cell.on("click", (event, d) => {
      event.stopPropagation();
      const origNode = d.data._orig || d.data;
      if (origNode.field_type != null) return;  // individual fields: no-op

      // Ref nodes (base_view / join): navigate to the actual view if it exists
      if (origNode.ref_type != null) {
        const target = findView(origNode.name);
        if (target) render(target);
        return;
      }

      if (origNode === rootOrigData) return;
      render(origNode);
    });
  }

  // ── Breadcrumb ─────────────────────────────────────────────────────────────
  function updateBreadcrumb(rootOrigData) {
    const idx = breadcrumbPath.findIndex(d => d === rootOrigData);
    if (idx === -1) {
      breadcrumbPath.push(rootOrigData);
    } else {
      breadcrumbPath.splice(idx + 1);
    }

    const bc = document.getElementById("breadcrumb");
    bc.innerHTML = breadcrumbPath.map((d, i) => {
      const isLast = i === breadcrumbPath.length - 1;
      const sep    = i > 0 ? `<span class="sep">/</span>` : "";
      if (isLast) return `${sep}<span class="current">${d.name}</span>`;
      return `${sep}<span data-idx="${i}">${d.name}</span>`;
    }).join("");

    bc.querySelectorAll("[data-idx]").forEach(el => {
      el.addEventListener("click", () => render(breadcrumbPath[+el.dataset.idx]));
    });
  }

  // ── Stats ──────────────────────────────────────────────────────────────────
  function updateStats(root, isDetail) {
    const viewCount  = root.descendants().filter(d => d.data.table_name && !d.data.ref_type).length;
    const topicCount = root.descendants().filter(d => d.data.base_view  && !d.data.ref_type).length;
    const fieldCount = root.value;

    let html = "";
    if (!isDetail) {
      if (topicCount) html += `<span><b>${topicCount}</b> topics</span>`;
      if (viewCount)  html += `<span><b>${viewCount}</b> views</span>`;
    }
    html += `<span><b>${fieldCount}</b> ${isDetail ? "fields" : "items"}</span>`;
    document.getElementById("stats").innerHTML = html;
  }

  // ── Legend ─────────────────────────────────────────────────────────────────
  function buildLegend() {
    const legend = document.getElementById("legend");
    const schemaItems = schemas.map(s => `
      <div class="legend-item">
        <div class="legend-swatch" style="background:${schemaColor(s)}"></div>
        <span>${s}</span>
      </div>`).join("");
    legend.innerHTML =
      `<div class="legend-item"><div class="legend-swatch" style="background:${TOPIC_COLOR}"></div><span>topics</span></div>` +
      `<div class="legend-item"><div class="legend-swatch" style="background:${JOIN_COLOR}"></div><span>joins</span></div>` +
      `<span class="legend-sep">|</span>` +
      schemaItems +
      `<span class="legend-sep">|</span>` +
      `<div class="legend-item"><div class="legend-swatch" style="background:${BASE_VIEW_COLOR}"></div><span>base view</span></div>` +
      `<div class="legend-item"><div class="legend-swatch" style="background:${JOIN_REF_COLOR}"></div><span>join ref</span></div>` +
      `<div class="legend-item"><div class="legend-swatch" style="background:${DIM_COLOR}"></div><span>dimensions</span></div>` +
      `<div class="legend-item"><div class="legend-swatch" style="background:${MEAS_COLOR}"></div><span>measures</span></div>` +
      `<span class="hint">Click a topic, view, or group to drill in · Breadcrumb to navigate back</span>`;
  }

  buildLegend();
  render(data);

  window.addEventListener("resize", () => { if (currentOrigData) render(currentOrigData); });

}).catch(err => {
  document.getElementById("chart").innerHTML =
    `<p style="padding:20px;color:#f87171">Failed to load treemap.json: ${err.message}</p>`;
});
</script>
</body>
</html>
